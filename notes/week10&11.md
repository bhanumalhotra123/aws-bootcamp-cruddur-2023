## CloudFormation

Started off CloudFormation with a guest instructor __Rohini Gaonkar, an AWS Sr. Dev__ Advocate leading instruction along with Andrew. We walked through setting up a basic CloudFormation template deploying an ECS Cluster. We also created a deploy script that deployed the cluster, along with a new S3 bucket named cfn-artifacts-1. In addition to this, we add a task to our .gitpod.yml file to install cfn-lint. Per ChatGPT, "cfn-lint is a tool used for linting CloudFormation templates, which checks for syntactical errors, best practices, and adherence to standards. It ensures the correctness and quality of the CloudFormation template."

![Screenshot 2024-03-03 050143](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/07dbf30e-5cfb-4b6c-8759-4502f195de08)

![Screenshot 2024-03-03 050154](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/49bca862-3f22-44dc-ae42-c691c69064d0)

![Screenshot 2024-03-03 051136](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/d54e182c-fe8c-4ece-a9b1-671ccb48d369)


![Screenshot 2024-03-03 071652](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/0d9a8d2e-2868-4bd3-bb0b-b2a42e8b194b)

![Screenshot 2024-03-03 172132](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/5b24d319-f257-4cce-9f28-c6f2db3d86bd)

![Screenshot 2024-03-03 221205](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/49602e32-4812-4abd-9159-0268203e477d)

# Networking Layer

Moving onto main instruction, we now have a cfn folder created in aws directory. We create a new folder within this directory named networking. Next we create a new file in this folder named template.yaml. We begin, just fleshing out the template.yaml, commenting what we're going to need.

```
AWSTemplateFormatVersion: 2010-09-09

# VPC
# IGW
# Route Tables
# Subnets
# Subnet A
# Subnet B
# Subnet C
```


We immediately consult AWS documentation for the VPC, which in CloudFormation is known as AWS::EC2::VPC.

```
AWSTemplateFormatVersion: 2010-09-09

# VPC
Resources:
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock:
      EnableDnsHostnames: true
      EnableDnsSupport: true
      InstanceTenancy: default
# IGW
# Route Tables
# Subnets
# Subnet A
# Subnet B
# Subnet C
```
  
In our ./bin/cfn directory, we create a new script named networking-deploy.

```
#! /usr/bin/env bash
set -e #stop the execution of the script if it fails

CFN_PATH="/workspace/aws-bootcamp-cruddur-2023/aws/cfn/networking/template.yaml"

cfn-lint $CFN_PATH 

aws cloudformation deploy \
    --stack-name "Cruddur" \
    --s3-bucket $CFN_BUCKET \
    --template-file $CFN_PATH \
    --no-execute-changeset \
    --capabilities CAPABILITY_NAMED_IAM

```
  
We set the value for a variable named CFN_PATH to the path for our template.yaml file for our network layer.

Next, we deploy a CloudFormation stack using the aws cloudformation deploy command. Here are the options and arguments used:

--stack-name: Specifies the name of the stack to create or update. In this case, it's set to "Cruddur".

--s3-bucket: Specifies the S3 bucket to upload the CloudFormation template to. The value of the CFN_BUCKET variable is expected to be set somewhere else in the script or in the environment.

--template-file: Specifies the path to the CloudFormation template file, which is set to the value of the CFN_PATH variable.

--no-execute-changeset: Indicates that the changeset created during the deployment should not be executed immediately. It allows you to review the changes before applying them.

--capabilities CAPABILITY_NAMED_IAM: Specifies the IAM capabilities required to create or update IAM resources in the CloudFormation stack. This capability is necessary when the template includes IAM resources.

```
export CFN_BUCKET="cfn-artifacts-1"
gp env CFN_BUCKET="cfn-artifacts-1"
```

![Screenshot 2024-03-03 082041](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/e7260560-ec95-4159-8f3c-8116e6a3ea11)

![Screenshot 2024-03-03 221621](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/16797595-d82e-452b-a9ef-a2f034c32919)



We have yet to fill in a value for the CidrBlock property in our networking template.yaml file.  https://cidr.xyz to determine what we'll use for our CIDR block for our VPC. this will determine the range of IP addresses that can be assigned to the resources within our VPC and also help us maintain higher availability of our resources.

![Screenshot 2024-03-11 145218](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/e92687d3-a0be-44e0-b1df-018bf64b87b1)

```
AWSTemplateFormatVersion: 2010-09-09

Resources: 
  VPC:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/26
      EnableDnsHostnames: true
      EnableDnsSupport: true
      InstanceTenancy: default
```

![Screenshot 2024-03-04 145742](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/48254ca0-76d7-41e6-9294-50e5124f730a)



When the VPC completes, we found that AWS also automatically creates a route table for you. In sifting through the resources, we had a bit of trouble with our previous configuration resources showing in the console. To remedy this, we decide to name the VPC resource as well, so we add tags to our template.yaml.

```
 Tags:
        - Key: Name
          Value: CruddurVPC
```

This will name our VPC resource as CruddurVPC. The next resource we must create is an internet gateway. We go back to AWS documentation and look specifically for AWS::EC2::InternetGateway. There's no properties to set for an internet gateway other than tags, so we implement the code:

```
  IGW:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html
    Type: AWS::EC2::InternetGateway
    Properties: 
      Tags:
        - Key: Name
          Value: CruddurIGW
```


When we create an internet gateway, we also must tell our CFN template to attach it. We consult AWS documentation for AWS::EC2::VPCGatewayAttachment then begin specifying properties.

```
  AttachIGW:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref IGW
```
  
You’ll note the !Ref function being used here. !Ref VPC and !Ref IGW are used for the VpcId and InternetGatewayId properties respectively to reference the VPC and IGW resources defined earlier in the template.

![ref](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/e30194f5-9249-4832-898d-11c66f3caec1)
  
Implementing a route table, which is responsible for directing network traffic for our VPC.

```
  RouteTable:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-routetable.html
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC 
      Tags:
        - Key: Name
          Value: CruddurRT
```

Next, we implement a route:

```
  RouteToIGW:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html
    Type: AWS::EC2::Route
    DependsOn: AttachIGW
    Properties:
      RouteTableId: !Ref RouteTable
      GatewayId: !Ref IGW
      DestinationCidrBlock: 0.0.0.0/0
```

Please bring your attention to the DependsOn property. This property indicates that RouteToIGW will not be created if AttachIGW does not exist. So if our gateway is not created, CloudFormation will not create our route either. The GatewayId property is returning the logical id of the internet gateway we'd like to use, so we point it towards our IGW gateway. We want our route going out to the internet, so we set the DestinationCidrBlock to 0.0.0.0/0. The reasoning is, 0.0.0.0/0 represents the entire IPv4 address space in CIDR notation.


We also implement a route for local as well, but we’re uncertain on the GatewayId:

```
  RouteToLocal:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html
    Type: AWS::EC2::Route
    DependsOn: AttachIGW
    Properties:
      RouteTableId: !Ref RouteTable
      GatewayId: "local"
      DestinationCidrBlock: 10.0.0.0/16
```

![image](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/10759a5a-0f25-4641-8049-2d96862aca35)

Error received: "The route identified by 10.0.0.0/16 already exists."
Action taken: Commented out route creation code, deleted CloudFormation stack in ROLLBACK_COMPLETE state, redeployed with VPC, internet gateway, and gateway attachment only.
Observation: Network ACL created automatically. NACLs act as stateless firewalls for subnet-level traffic control.
Tip: Ensure NACLs have outbound routes to avoid blocking internet access.


We uncomment the lines of code creating our route table and our RouteToIGW. Then, we again deploy our networking CFN template. When the changeset is created, we execute it from CFN. When we go back to EC2 to view our our new route table, it automatically created the route to local as well:

![image](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/5d64a896-4151-45c0-b9c3-13ee659418c0)


Since the route to local is already being created, we remove the commented lines of code creating that route. Next, we must create our subnets. We might decide that our database must sit privately, so in addition to our public subnets, we create private ones as well.

```
  SubnetPub1:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
    Type: AWS::EC2::Subnet
    Properties:
      AssignIpv6AddressOnCreation: false
      AvailabilityZone: us-east-1a
      CidrBlock: 10.0.0.0/24
      EnableDns64: false
      MapPublicIpOnLaunch: true # public subnet
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: CruddurSubnetPub1
  SubnetPub2:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
    Type: AWS::EC2::Subnet
    Properties:
      AssignIpv6AddressOnCreation: false
      AvailabilityZone: us-east-1b
      CidrBlock: 10.0.4.0/24
      EnableDns64: false
      MapPublicIpOnLaunch: true # public subnet
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: CruddurSubnetPub2  
  SubnetPub3:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
    Type: AWS::EC2::Subnet
    Properties:
      AssignIpv6AddressOnCreation: false
      AvailabilityZone: us-east-1c
      CidrBlock: 10.0.8.0/24
      EnableDns64: false
      MapPublicIpOnLaunch: true # public subnet
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: CruddurSubnetPub3
  SubnetPriv1:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
    Type: AWS::EC2::Subnet
    Properties:
      AssignIpv6AddressOnCreation: false
      AvailabilityZone: us-east-1a
      CidrBlock: 10.0.12.0/24
      EnableDns64: false
      MapPublicIpOnLaunch: false # private subnet
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: CruddurSubnetPriv1  
  SubnetPriv2:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
    Type: AWS::EC2::Subnet
    Properties:
      AssignIpv6AddressOnCreation: false
      AvailabilityZone: us-east-1b
      CidrBlock: 10.0.16.0/24
      EnableDns64: false
      MapPublicIpOnLaunch: false # private subnet
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: CruddurSubnetPriv2
  SubnetPriv3:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
    Type: AWS::EC2::Subnet
    Properties:
      AssignIpv6AddressOnCreation: false
      AvailabilityZone: us-east-1c
      CidrBlock: 10.0.20.0/24
      EnableDns64: false
      MapPublicIpOnLaunch: false # private subnet
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: CruddurSubnetPriv3 
```

A few key takeaways from these properties:

AssignIpv6AddressOnCreation: controls whether IPV6 addresses are automatically assigned to instances that are launched in the subnet

AvailabilityZone: the availability zone within AWS that our subnet is created in

EnableDns64: controls whether DNS64 is enabled for an IPv6 enabled subnet. Since we're not using IPv6, this value is false

MapPublicIpOnLaunch: controls the automatic assignment of a public IP address to instances launched within a subnet. Notice our public subnets have this set to true, where our private ones are set to false.

Next we must implement our SubnetRouteTableAssocation resources. This will associate our subnets with our route table in the VPC.

```
SubnetPub1RTAssociation:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref SubnetPub1
      RouteTableId: !Ref RouteTable  
  SubnetPub2RTAssociation:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html  
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref SubnetPub2
      RouteTableId: !Ref RouteTable  
  SubnetPub3RTAssociation:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html  
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref SubnetPub3
      RouteTableId: !Ref RouteTable  
  SubnetPriv1RTAssociation:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html  
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref SubnetPriv1
      RouteTableId: !Ref RouteTable  
  SubnetPriv2RTAssociation:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html  
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref SubnetPriv2
      RouteTableId: !Ref RouteTable  
  SubnetPriv3RTAssociation:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnetroutetableassociation.html  
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref SubnetPriv3
      RouteTableId: !Ref RouteTable
```

With this completed, we now try to deploy our template.yaml for our networking layer again. This time, cfn-lint gives us some feedback.

![image](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/9238db89-30a9-46c6-bb2e-b9c7d38a3a8d)

To circumvent these warnings, we go ahead and pass some parameters in our networking template.
```
Parameters:
  Az1:
    Type: AWS::EC2::AvailabilityZone::Name
    Default: us-east-1a
  Az2:
    Type: AWS::EC2::AvailabilityZone::Name
    Default: us-east-1b
  Az3:
    Type: AWS::EC2::AvailabilityZone::Name
    Default: us-east-1c
```

Then we use the !Ref function to pass the values in our template, per subnet. For example:

```
AvailabilityZone: !Ref Az1
```

We again deploy the CFN template, this time the changeset is created. We execute it via AWS. The create fails this time, stating the IPv6CidrBlock cannot be empty. We review AWS documentation to see why.

![image](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/b2e8ddf7-8cf9-4c21-895c-219b718012a7)


Per the snippet above, since we specified AssignIpv6AddressOnCreation, we must also specify Ipv6CidrBlock. Since neither is being used, we just remove the AssignIpv6AddressOnCreation property from our template. With the template file updated, we again run our networking-deploy script. We execute the changeset from CloudFormation and we have an UPDATE_COMPLETE status.

![Screenshot 2024-03-04 150018](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/4980f762-3559-4c19-87e1-b37c9cdaa5a0)


we’re not going to implement security groups at this layer, because security groups are usually around particular services. We also decide we want to clean things up in our code a little bit, particularly our CidrBlock properties. We do this by implementing some parameters:

```
Parameters:
  SubnetCidrBlocks: 
    Description: "Comma-delimited list of CIDR blocks for our private public subnets"
    Type: CommaDelimitedList
    Default: > 
      10.0.0.0/24, 
      10.0.4.0/24, 
      10.0.8.0/24, 
      10.0.12.0/24, 
      10.0.16.0/24, 
      10.0.20.0/24   
```


You’ll note that we’re using a Comma Delimited List for our SubnetCidrBlocks parameter. Andrew explains how we're implementing this by using what's known as a scalar variable in Yaml.
A scalar is a variable that holds one value at a time. Scalars are generally primitive data types e.g. String, Int, Bool". We're using what's known as a folded block scalar style, using the folded start with a >. This allows CloudFormation to treat our parameter as a single string.
  
We’re able to reference these values for our CidrBlock property by using the !Select function.
```
CidrBlock: !Select [0, !Ref SubnetCidrBlocks]
```


In the above code snippet, we’re selecting the first element from the list of subnet CIDR blocks, i.e. 10.0.0.0/24.

We also add a parameter for our VPC CidrBlock property as well.
```
Parameters:
  VpcCidrBlock:
    Type: String
    Default: 10.0.0.0/16
```

We then pass the value of the parameter to the property using the !Ref function.

```
Resources: 
  VPC:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref VpcCidrBlock
```

From there, we update the tags for all of our resources that have them in our template.yaml to utilize pseudo parameters from AWS, in this instance, the AWS::StackName parameter for our VPC. 
https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/pseudo-parameter-reference.html

```
 Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}VPC"
```

Adding outputs will allow us to expose information about our resources created by the stack. We'll be able to use these outputs for other stacks when we implement future layers.


```
Outputs:
  VpcId:
    Value: !Ref VPC
    Export:
      Name: VpcId
  VpcCidrBlock:
    Value: !GetAtt VPC.CidrBlock
    Export:
      Name: VpcCidrBlock
  SubnetCidrBlocks:
    Value: !Join [",", !Ref SubnetCidrBlocks]
    Export:
      Name: SubnetCidrBlocks
  SubnetIds: 
    Value: !Join 
      - "," 
      - - !Ref SubnetPub1 
        - !Ref SubnetPub2 
        - !Ref SubnetPub3 
        - !Ref SubnetPriv1
        - !Ref SubnetPriv2
        - !Ref SubnetPriv3
    Export: 
      Name: SubnetIds
  AvailabilityZones:
    Value: !Join 
      - "," 
      - - !Ref Az1
        - !Ref Az2
        - !Ref Az3  
    Export: 
      Name: AvailabilityZones
```

Let’s breakdown each output:

VpcId: This output references the VPC resource using !Ref VPC. It exports the value with the name VpcId. This output can be referenced in other stacks to retrieve the VPC ID.

VpcCidrBlock: This output uses the !GetAtt function to retrieve the CidrBlock attribute of the VPC resource. It exports the value with the name VpcCidrBlock. This output provides the CIDR block of the VPC.

SubnetCidrBlocks: This output uses the !Join function to concatenate the values of SubnetCidrBlocks, which are referenced by !Ref SubnetCidrBlocks, separated by commas. It exports the joined value with the name SubnetCidrBlocks. This output provides a comma-separated list of subnet CIDR blocks.

SubnetIds: This output uses the !Join function to concatenate the values of SubnetPub1, SubnetPub2, SubnetPub3, SubnetPriv1, SubnetPriv2, and SubnetPriv3 separated by commas. The subnet values are obtained using !Ref for each subnet. It exports the joined value with the name SubnetIds. This output provides a comma-separated list of subnet IDs.

AvailabilityZones: This output uses the !Join function to concatenate the values of Az1, Az2, and Az3 separated by commas. The availability zone values are obtained using !Ref for each availability zone. It exports the joined value with the name AvailabilityZones. This output provides a comma-separated list of availability zones.

When we again deploy then execute the changeset from CloudFormation, we now have Outputs available under the Outputs tab.

![Screenshot 2024-03-04 150926](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/3bb541a5-bcbe-4a8b-ba83-cd85e770a25d)

![Screenshot 2024-03-04 180827](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/ecb74429-aff1-4b8b-b06e-053128d72f21)




Cluster Layer
Next, we are going to implement our Cluster layer to define our Fargate cluster.

```
AWSTemplateFormatVersion: 2010-09-09

# Parameters:
Resources:
  ECSCluster: #LogicalName
    Type: 'AWS::ECS::Cluster'
    Properties:
      ClusterName: MyCluster1
      CapacityProviders:
        - FARGATE
# Outputs:
```

You can see we’re creating an ECS Cluster resource. We continue on with this, adding properties for the cluster:

```
AWSTemplateFormatVersion: 2010-09-09

# Parameters:
Resources:
  FargateCluster:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-cluster.html 
    Type: AWS::ECS::Cluster
    Properties: 
      ClusterName: !Sub "${AWS::StackName}FargateCluster"
      CapacityProviders: 
        - FARGATE 
      ClusterSettings: 
        - Name: containerInsights
          Value: enabled
      Configuration: 
        ExecuteCommandConfiguration:
          Logging: DEFAULT
      ServiceConnectDefaults: 
        Namespace: cruddur
# Outputs:
```

Some information on the properties of the cluster:

CapacityProviders: This property specifies the capacity providers to associate with the cluster. In this case, it has a single value FARGATE, indicating that the cluster should use AWS Fargate capacity provider.

ClusterSettings: This property allows you to configure additional settings for the cluster. In this case, it specifies a setting named containerInsights with the value enabled, enabling the CloudWatch Container Insights feature.

Configuration: This property allows you to specify additional configurations for the cluster. Here, it includes the ExecuteCommandConfiguration property with Logging set to DEFAULT, which configures the default logging behavior for execute command functionality.

ServiceConnectDefaults: This property allows you to specify a default Service Connect namespace. Once the default namespace is set, any new services with Service Connect turned on that are created in the cluster are added as client service in the namespace. We set the Namespace property to cruddur.

While working through AWS documentation for this, we come upon the Description section and decide to go back and add this to our networking layer template.yaml.



We begin working on the cluster-deploy script now as well by copying our networking-deploy script as a start off point, then editing it down.

```
#! /usr/bin/env bash
set -e #stop the execution of the script if it fails

CFN_PATH="/workspace/aws-bootcamp-cruddur-2023/aws/cfn/cluster/template.yaml"

cfn-lint $CFN_PATH 

aws cloudformation deploy \
    --stack-name "Cruddur" \
    --s3-bucket $CFN_BUCKET \
    --template-file $CFN_PATH \
    --no-execute-changeset \
    --tags group="cruddur-cluster" \
    --capabilities CAPABILITY_NAMED_IAM
```

You’ll notice the CFN_PATH is now updated to the path for our cluster template.yaml file, and we're also propagating down tags from the CloudFormation commands. We go back to our networking-deploy script and implement the tags there as well. Then, we move forward with implementing our cluster layer through the template.yaml. We add an application load balancer.

```
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-loadbalancer.html
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub "${AWS::StackName}ALB"
      Type: application
      IpAddressType: ipv4
      # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticloadbalancingv2-loadbalancer-loadbalancerattributes.html
      Scheme: internet-facing
      SecurityGroups: 
        - security group ids
      Subnets: 
      LoadBalancerAttributes: 
        - Key: routing.http2.enabled
          Value: true
        - Key: routing.http.preserve_host_header.enabled
          Value: false
        - Key: deletion_protection.enabled
          Value: true
        - Key: load_balancing.cross_zone.enabled
          Value: true
        - Key: access_logs.s3.enabled
          Value: false
          # In case we want to turn on logs
        # - Key: access_logs.s3.bucket
          # Value: bucket-name
        # - Key: access_logs.s3.prefix
          # Value: ""
```


Remember that we have left the Subnets property blank for now. More details on the properties we're setting here:

Type: Indicates the type of load balancer. In this case, it is set to application, which represents an application load balancer.

IpAddressType: Specifies the IP address type for the ALB. Here, it is set to ipv4, indicating the use of IPv4 addresses. It is the most common choice and allows the ALB to handle traffic over IPv4. The other option we could've selected is dualstack. This option specifies that the ALB should use both IPv4 and IPv6 addresses. It enables the ALB to handle traffic over both IPv4 and IPv6 protocols

LoadBalancerAttributes: Specifies a list of load balancer attributes and their corresponding values. Each attribute is represented as a dictionary with a Key and Value pair.

Key: routing.http2.enabled: Enables HTTP/2 routing for the ALB.

Key: routing.http.preserve_host_header.enabled: Enables preserving the host header for HTTP routing. When set to false, the host header is not preserved when forwarding requests to the target groups.

Key: deletion_protection.enabled: Enables deletion protection for the ALB. When deletion protection is enabled, the ALB cannot be deleted accidentally.

Key: load_balancing.cross_zone.enabled: Enables cross-zone load balancing. When enabled, the ALB evenly distributes traffic across all availability zones specified in the subnets property.

Key: access_logs.s3.enabled: Enables access logs to be stored in Amazon S3. When set to false, no access logs will be generated and stored.

We also commented out a couple of lines of code that would enable logging of our S3 bucket with a name value given by us, which would capture detailed information about every request made to the bucket, such as the requester’s IP address, the time of the request, the HTTP status code, and more. The access_logs.s3.prefix property specifies a prefix or a directory within the access logging S3 bucket where the logs should be stored. By using a prefix, you can organize and categorize the logs based on specific criteria, such as by date, requester, or any other relevant information.

Also notice that our SecurityGroups property does not have a valid value yet. We must create our security groups as well to reference the logical ID of the SG. We continue on with fleshing out the cluster template, adding a Descritpion field to the template.

```
Description: |
  The networking and cluster configuration to support Fargate containers:
  - ECS Fargate Cluster
  - Application Load Balancer (ALB)
    -IPv4 only
    - internet facing
  - ALB Security Group
  - HTTPS Listener
    - send root domain to frontend Target Group
    - send API subdomain to backend Target Group
  - HTTP Listener
    - redirects to HTTPS Listener
  - Backend Target Group
  - Frontend Target Group
```


A Description field in a CFN template provides an overview of what the template does. It's not mandatory for a CFN template, but it is considered a good practice to include it, as it can help other team members, stakeholders, or reviewers understand the purpose and functionality of the template.

Before we implement security groups, we must add the listeners for our HTTP and HTTPS. As noted in our Description, the HTTPS Listener will send HTTPS requests from our ALB to our frontend target group and send API requests to our backend target group. The HTTP listener will redirect to the HTTPS listener.

```
  HTTPSListener:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listener.html
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      Protocol: HTTPS    
      Port: 443
      LoadBalancerArn: !Ref ALB           
      Certificates: 
        - CertificateArn: !Ref CertificateArn
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref FrontendTG
  HTTPListener: 
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listener.html
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      Protocol: HTTP
      Port: 80
      LoadBalancerArn: !Ref ALB        
      DefaultActions:
        - Type: redirect
          RedirectConfig:
            Protocol: "HTTPS"
            Port: 443
            Host: "#{host}"
            Path: "/#{path}"
            Query: "#{query}"
```

For our HTTPSListener:

Protocol: Sets the listener's protocol to HTTPS, indicating that it will handle incoming HTTPS traffic.

Port: Defines the port number on which the listener will listen for HTTPS requests (port 443 in this case).

LoadBalancerArn: Refers to the ARN of the ALB to which the listener will be attached.

Certificates: Specifies the SSL/TLS certificate to be used for encrypting and decrypting HTTPS traffic. It references the certificate ARN using the !Ref intrinsic function.

DefaultActions: Defines the default action to be taken by the listener when it receives a request. In this case, it is set to forward the request to a target group referenced by FrontendTG, which we will define a bit further down.

For our HTTPListener:

DefaultActions: Defines the default action to be taken by the listener when it receives a request. In this case, it is set to redirect the request to HTTPS using the specified RedirectConfig.

Type: Specifies the action type as "redirect".

RedirectConfig: Provides configuration options for the redirect action, including the target protocol (HTTPS), port (443), host, path, query, and status code (HTTP_301 indicating a permanent redirect).

The Host, Path, and Query properties in the RedirectConfig section of the HTTPListener resource define how the incoming request's host, path, and query parameters are preserved during the HTTP to HTTPS redirection.


We’re passing a parameter as the value for CertificateArn. The parameter is called CertificateArn, so we add this as a parameter as well.
```
Parameters:
  CertificateArn:
    Type: String
```





From here, we add our application load balancer security group, or ALBSG.

```
  ALBSG:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html
    Type: AWS::EC2::SecurityGroup
    Properties: 
      GroupName: !Sub "${AWS::StackName}AlbSG"
      GroupDescription: Public Facing SG for our Cruddur ALB
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: '0.0.0.0/0'
          Description: INTERNET HTTPS
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: '0.0.0.0/0'
          Description: INTERNET HTTP
```

The properties defined here GroupName and GroupDescription sets the name and provides a description of the security group. The name cannot start with "sg" and the GroupDescription is a required property. There's a couple rules set in the SecurityGroupIngress property that I'll explain further:

The first rule allows TCP traffic on port 443 (HTTPS) from any source IP (0.0.0.0/0) and provides a description indicating that it is for internet HTTPS traffic.

```
     - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: '0.0.0.0/0'
          Description: INTERNET HTTPS
```

The second rule allows TCP traffic on port 80 (HTTP) from any source IP (0.0.0.0/0) and provides a description indicating that it is for internet HTTP traffic.
```
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: '0.0.0.0/0'
          Description: INTERNET HTTP
```

With our security group defined, we can now go back to our load balancer to define the security group property:
```
 ALB:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-loadbalancer.html
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub "${AWS::StackName}ALB"
      Type: application
      IpAddressType: ipv4
      # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticloadbalancingv2-loadbalancer-loadbalancerattributes.html
      Scheme: internet-facing
      SecurityGroups: 
        - !Ref ALBSG
```


We must add an additional rule for our HTTPS Listener to redirect API requests to our backend target group, which we've yet to define as well. To do this, we add a Listener Rule.

```
ApiALBListenerRule:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listenerrule.html
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Conditions: 
        - Field: host-header
          HostHeaderConfig: 
            Values: 
              - api.gooddesignsolutions.in
      Actions: 
        - Type: forward
          TargetGroupArn: !Ref BackendTG
      ListenerArn: !Ref HTTPSListener
      Priority: 1
```

Here’s a further breakdown of our properties:

Conditions: Specifies the conditions that must be met for the rule to be applied.

Field: Sets the condition field to "host-header", which means the rule will be applied based on the value of the host header in the incoming request. The host header indicates the specific host or domain the HTTP request wants to communicate with. The host header allows the server to identify which virtual host or website the client is targeting when multiple websites or applications are hosted on the same server.

HostHeaderConfig: Specifies the configuration for the host header condition.

Values: Sets the expected value for the host header to api.thejoshdev.com. The rule will match requests with this host-header value.

The Actions properties forwards the requests that are matched with the host-header set in our Conditions, in this case, api.thejoshdev.com and forwards them to the BackendTG target group, which we still need to define.

The Priority property sets the priority of the rule to 1, which determines the order of rules to be evaluated. The lower the number, the higher the priority.


```

BackendTG:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-targetgroup.html
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties: 
      Name: !Sub "${AWS::StackName}BackendTG"
      Port: !Ref BackendPort
      HealthCheckEnabled: true      
      HealthCheckProtocol: !Ref BackendHealthCheckProtocol         
      HealthCheckIntervalSeconds: !Ref BackendHealthCheckIntervalSeconds
      HealthCheckPath: !Ref BackendHealthCheckPath
      HealthCheckPort: !Ref BackendHealthCheckPort
      HealthCheckTimeoutSeconds: !Ref BackendHealthCheckTimeoutSeconds
      HealthyThresholdCount: !Ref BackendHealthyThresholdCount
      UnhealthyThresholdCount: !Ref BackendUnhealthyThresholdCount
      IpAddressType: ipv4
      Matcher: 
        HttpCode: 200
      Protocol: HTTP
      ProtocolVersion: HTTP2
      TargetGroupAttributes: 
        - Key: deregistration_delay.timeout_seconds
          Value: 0
      VpcId: CROSS_REFERENCE_STACK    
  FrontendTG:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-targetgroup.html
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties: 
      Name: !Sub "${AWS::StackName}FrontendTG"
      Port: !Ref FrontendPort
      HealthCheckEnabled: true      
      HealthCheckProtocol: !Ref FrontendHealthCheckProtocol         
      HealthCheckIntervalSeconds: !Ref FrontendHealthCheckIntervalSeconds
      HealthCheckPath: !Ref FrontendHealthCheckPath
      HealthCheckPort: !Ref FrontendHealthCheckPort
      HealthCheckTimeoutSeconds: !Ref FrontendHealthCheckTimeoutSeconds
      HealthyThresholdCount: !Ref FrontendHealthyThresholdCount
      UnhealthyThresholdCount: !Ref FrontendUnhealthyThresholdCount
      IpAddressType: ipv4
      Matcher: 
        HttpCode: 200
      Protocol: HTTP
      ProtocolVersion: HTTP2
      TargetGroupAttributes: 
        - Key: deregistration_delay.timeout_seconds
          Value: 0
      VpcId: CROSS_REFERENCE_STACK
```

Some key takeaways from the properties we defined for our target groups that I haven’t referenced yet:

HealthCheckEnabled: Indicates whether health checks are enabled for the target group. It is set to true.

HealthCheckProtocol: References the protocol used for health checks.

HealthCheckIntervalSeconds: References the interval between health checks in seconds.

HealthCheckPath: References the path used for health checks.

HealthCheckPort: References the port used for health checks.

HealthCheckTimeoutSeconds: References the timeout for health checks in seconds.

HealthyThresholdCount: References the number of consecutive successful health checks required to mark a target as healthy.

UnhealthyThresholdCount: References the number of consecutive failed health checks required to mark a target as unhealthy.

Matcher: Defines the HTTP response code used to determine the health of a target.

TargetGroupAttributes: An array property that allows you to define multiple attributes for the target group.

“Key: deregistration_delay.timeout_seconds specifies the attribute key as deregistration_delay.timeout_seconds. This key refers to the attribute that controls the amount of time a target is kept in the "draining" state after it is deregistered from the target group. The "draining" state allows existing connections to complete before the target is completely removed."

With that information, we know that the Value property then sets that value to 0, which will mean the target will immediately be removed from the target group once it's deregistered.

We’re also passing a lot of parameters here, so we add them to our Parameters section of the template.


We’re also passing a lot of parameters here, so we add them to our Parameters section of the template.


```
Parameters:
  CertificateArn:
    Type: String
  # Frontend -----------
  FrontendPort:
    Type: Number
    Default: 3000      
  FrontendHealthCheckIntervalSeconds:
    Type: Number
    Default: 15
  FrontendHealthCheckPath: 
    Type: String
    Default: "/"
  FrontendHealthCheckPort: 
    Type: String
    Default: 80
  FrontendHealthCheckProtocol: 
    Type: String
    Default: HTTP
  FrontendHealthCheckTimeoutSeconds: 
    Type: Number
    Default: 5
  FrontendHealthyThresholdCount: 
    Type: Number
    Default: 2
  FrontendUnhealthyThresholdCount: 
    Type: Number
    Default: 2
  # Backend -----------  
  BackendPort:
    Type: Number
    Default: 4567  
  BackendHealthCheckIntervalSeconds:
    Type: Number
    Default: 15
  BackendHealthCheckPath: 
    Type: String
    Default: "/api/health-check"
  BackendHealthCheckPort: 
    Type: String
    Default: 80
  BackendHealthCheckProtocol: 
    Type: String
    Default: HTTP
  BackendHealthCheckTimeoutSeconds: 
    Type: Number
    Default: 5
  BackendHealthyThresholdCount: 
    Type: Number
    Default: 2
  BackendUnhealthyThresholdCount: 
    Type: Number
    Default: 2
```

You may also note that above for our target groups we haven’t fully implemented the VpcId property. We need to import the value of this from our networking template.yaml via a cross-stack reference. We do this through the use of the Fn::ImportValue function. The Fn::ImportValue function returns the value of an output exported by another stack. In our case, an export from our networking stack. We begin by passing the stack as a parameter.

```
Parameters:
  NetworkingStack:
    Type: String  
    Description: This is our base layer of networking components e.g. VPC, Subnets
    Default: CrdNet
```

We then add the Fn::ImportValue function as the value of our VpcId property.
```
      VpcId: 
        Fn::ImportValue:
          !Sub ${NetworkingStack}VpcId
```

This is added for both the FrontendTG and BackendTG target groups. We're also using the !Sub function to substitute the NetworkingStack variable into the string.

Since we added the parameters to allow cross stack references to our networking layer, we’re now prepared to finish implementing the Subnets property we left blank earlier in our ALB. Andrew notes this is tricky, because they come in as a string, but we're going to need to break them down into an array. To do this, we're going to use the Fn::Split function. This function splits a string into a list of string values, so we can select an element from the resulting string list. Here's a further breakdown of that syntax:   ___Fn::Split: [delimiter, source string]___

```
 ALB:
    # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-loadbalancer.html
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub "${AWS::StackName}ALB"
      Type: application
      IpAddressType: ipv4
      # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticloadbalancingv2-loadbalancer-loadbalancerattributes.html
      Scheme: internet-facing
      SecurityGroups: 
        - !Ref ALBSG
      Subnets: !Split [",", !ImportValue { "Fn::Sub": "${NetworkingStack}VpcId" }]
```

We are using the Fn::Split function (seen in short form here). You can see that our delimiter is a "," , with the source string using the Fn::ImportValue function we used above. Andrew implemented his a bit differently, but I believe I was running into indentation problems, and instead implemented it as one line, as seen above. Andrew's looked like this:

![image](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/7b13a351-ec9c-4653-9b27-e6f54f393f70)


In reviewing our template prior to deploying, it’s noted that our original naming for our networking stack was just Cruddur, which will not work for the additional layers we're going to be implementing. We must go back and rename it, setting a naming convention for future layers. We do this by going back to our networking-deploy script.

```
#! /usr/bin/env bash
set -e #stop the execution of the script if it fails
CFN_PATH="/workspace/aws-bootcamp-cruddur-2023/aws/cfn/networking/template.yaml"
cfn-lint $CFN_PATH 

aws cloudformation deploy \
    --stack-name "CrdNet" \
    --s3-bucket $CFN_BUCKET \
    --template-file $CFN_PATH \
    --no-execute-changeset \
    --tags group="cruddur-networking" \
    --capabilities CAPABILITY_NAMED_IAM
```


Then we update cluster-deploy.
```
#! /usr/bin/env bash
set -e #stop the execution of the script if it fails
CFN_PATH="/workspace/aws-bootcamp-cruddur-2023/aws/cfn/networking/template.yaml"
cfn-lint $CFN_PATH 

aws cloudformation deploy \
    --stack-name "CrdCluster" \
    --s3-bucket $CFN_BUCKET \
    --template-file $CFN_PATH \
    --no-execute-changeset \
    --tags group="cruddur-cluster" \
    --capabilities CAPABILITY_NAMED_IAM
```

To implement this change, we’re going to have to tear down our existing network stack. We head back over to CloudFormation, and delete the Cruddur stack.

![image](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/fda46be0-bb17-4bf4-8d3e-092378f26785)

Andrew mentions we’re also using the Cruddur name for our existing AWS resources as well, which we may run into conflicts about with future CFN templates. To circumvent this, we delete our existing AWS resources including frontend and backend services in ECS, Fargate cluster in ECS, ALB, target groups, Namespace from Cloud Map.

We are now ready to redeploy our network stack. We run networking-deploy, then head over to CloudFormation.

![image](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/f3f1d4c2-3b7b-4a90-b270-dd95e75b5fde)

We execute the changeset from CloudFormation, and while we’re waiting come to find that we didn’t update the value imported for our Subnets property of our ALB. To fix this, we have to go back over to our networking template.yaml and make sure of the name of the property being exported for SubnetIds.

![image](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/d5142c12-cc45-4d47-8c26-dd338a93a1c1)

It’s just SubnetIds, so we fix this in our cluster template.
```
   Subnets: !Split [",", !ImportValue { "Fn::Sub": "${NetworkingStack}SubnetIds" }]
```

