# ECS and alot more

Content for the coming 2 weeks(week 6 and week 7) being so closely related, we would combine them so as to give my fellow bootcampers and myself plenty of time to implement everything and get completely caught up.


We can't use psql command here which we used to connect to the db as we haven't installed it and it isn't worth setting it up.
So we are just testing the connection instead.
Created a new script file in ‘/backend-flask/db/’ named test.

```
#!/usr/bin/env python3

import psycopg
import os
import sys

connection_url = os.getenv("CONNECTION_URL")

conn = None
try:
  print('attempting connection')
  conn = psycopg.connect(connection_url)
  print("Connection successful!")
except psycopg.Error as e:
  print("Unable to connect to the database:", e)
finally:
  conn.close()
```
![test-connection](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/ce302b93-aa30-41f9-8833-dfd598f70210)


   
We need to implement a health check endpoint into our app as well. We begin in the backend. In our ‘app.py’ file, we add a health check.

```
@app.route('/api/health-check')
def health_check():
  return {'success': True}, 200
```

### The reason of not using tools like curl in this:
Shell Injection: If your application dynamically constructs curl commands using user input or other untrusted data, it could be vulnerable to shell injection attacks, allowing attackers to execute arbitrary commands within the container.
  
```
#!/usr/bin/env python3

import urllib.request

try:
  response = urllib.request.urlopen('http://localhost:4567/api/health-check')
  if response.getcode() == 200:
    print("[OK] Flask server is running")
    exit(0) # success
  else:
    print("[BAD] Flask server is not running")
    exit(1) # false
# This for some reason is not capturing the error....
#except ConnectionRefusedError as e:
# so we'll just catch on all even though this is a bad practice
except Exception as e:
  print(e)
  exit(1) # false
```

![app-health-check](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/0bc628b2-0d74-424a-baf3-c77503919912)


### we will also need a new AWS Cloudwatch group.
 We login to the AWS Console, then go to Cloudwatch, and view Logs > Log groups. Then back in our codespace, > from the CLI, we create the log group.
  

![log-group](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/de8b4aab-4f5a-47b4-b985-b156d47e8f73)


![log-group](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/c2612c5c-5260-423b-9026-c55171334f17)


Created our ECS cluster. Did it through the CLI instead of the console because AWS changes their UI so frequently, there’s no point in getting familiar with one layout.

```
aws ecs create-cluster \
--cluster-name cruddur \
--service-connect-defaults namespace=cruddur
```

The ‘ — service-connect-defaults’ lets us set the name for the default Service Connect namespace to our cluster. It’s a nicer way of mapping things internally using AWS Cloudmap.
![Screenshot 2024-01-29 163620](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/c6061c26-476a-4b2e-9676-d517c9cf451a)
![Screenshot 2024-01-29 163728](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/a9e021b0-bf69-4898-9221-e2a5147d5f2c)
![Screenshot 2024-01-29 163857](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/eef74f7b-8335-4147-aaed-3e00c8352b0e)


 we’re going to use AWS ECR to house our containers. To do this, we must first create a repository.


```
aws ecr create-repository \
  --repository-name cruddur-python \
  --image-tag-mutability MUTABLE
```

![Screenshot 2024-01-29 191335](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/4a5240e6-5e38-4c78-9259-501128a02512)

![Screenshot 2024-01-29 191504](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/f1af3d44-3f83-4d5f-a1f1-b4d7dea9422f)
![Screenshot 2024-01-29 191512](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/dfe6994d-cf24-4e99-8bd2-1ac8c90e4848)

This gives us a repository named ‘cruddur-python’ with the image tag being mutable. This will prevent tags from being overwritten. 

Next, we must login to ECR using our AWS credentials. The command here uses our env variables we’ve already set in our environment.

```
aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com"
```

![Screenshot 2024-01-29 191803](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/95467e35-b8fa-4bda-9cb5-24e99b78ac07)


We can now push container images. We set our path to the repo.
```
export ECR_PYTHON_URL="$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/cruddur-python"
```

We pull a version of Python image 

```
docker pull python:3.10-slim-buster

```


We then tag the image.

```
docker tag python:3.10-slim-buster $ECR_PYTHON_URL:3.10-slim-buster
```


Next, we push the image.
```
docker push $ECR_PYTHON_URL:3.10-slim-buster
```
![Screenshot 2024-01-29 192331](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/51d5556b-4557-4d69-9930-da4d06134d32)


From ECR in the AWS console, we can now see our image in the repository.

![Screenshot 2024-01-29 192345](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/8c9837aa-fb16-4e8f-80ee-d86557fe0443)

Now we must update our Flask app to use this. We navigate to our ‘backend-flask’ location, then edit our Dockerfile.

```
FROM 774944129490.dkr.ecr.us-east-1.amazonaws.com/cruddur-python:3.10-slim-buster
# Inside Container
# make a new folder inside container
WORKDIR /backend-flask

# Outside Container -> Inside Container
# this contains the libraries want to install to run the app
COPY requirements.txt requirements.txt

# Inside Container
# Install the python libraries used for the app
RUN pip3 install -r requirements.txt

# Outside Container -> Inside Container
# . means everything in the current directory
# first period . - /backend-flask (outside container)
# second period . /backend-flask (inside container)
COPY . .

ENV PYTHONUNBUFFERED=1

EXPOSE ${PORT}

# CMD (Command)
# python3 -m flask run --host=0.0.0.0 --port=4567
CMD [ "python3", "-m" , "flask", "run", "--host=0.0.0.0", "--port=4567", "--debug"]
```


To test the new configuration in our Dockerfile, we run select services from the CLI.
```
docker compose up backend-flask db
```

After this completes, we can see that the backend is running, as the port is now open. We test the health-check.

We can now start pushing this. So we again make another repo.
```
aws ecr create-repository \
  --repository-name backend-flask \
  --image-tag-mutability MUTABLE
```
Next we set the URL:
```
export ECR_BACKEND_FLASK_URL="$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/backend-flask"
echo $ECR_BACKEND_FLASK_URL
```

Now we build the image. On our previous container, we didn’t need to build an image, we pulled it. Andrew confirms we must make sure we’re in the backend-flask directory prior to running the command.

```
docker build -t backend-flask .
```

We then tag and push the image.
```
docker tag backend-flask:latest $ECR_BACKEND_FLASK_URL:latest
```

We make sure to tag the push with the tag ‘:latest’ although this isn’t necessary. It will get tagged this way by default. Also when using AWS, Andrew explained it will always look for the ‘:latest’ tag.
```
docker push $ECR_BACKEND_FLASK_URL:latest
```

![Screenshot 2024-01-29 200136](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/eb23a4fc-f3e8-42ae-8d7b-91ad5299dcd3)

From here, we go back to ECS in the AWS console. Andrew walks us through the UI of the existing options and configuration of setting up a service. While explaining task definitions, we find that the Cloudwatch log group we created earlier is improperly named.

We navigate back to Cloudwatch, and from the UI, we manually create a new log group named cruddur, with a retention period of 1 day.

![image](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/5f29f8e6-9cd5-43db-8e5a-a1c84665e847)

Back in our code, we now need to finish creating our roles and setup the policy for our task definitions.

Our service-execution-policy.json followed by our service-assume-role-execution-policy.json:


```
{
    "Version":"2012-10-17",
    "Statement":[{
        "Effect": "Allow",
        "Action": [
          "ssm:GetParameters",
          "ssm:GetParameter"
        ],
        "Resource": "arn:aws:ssm:us-east-1:554621479919:parameter/cruddur/backend-flask/*"        
    }]
}
```

```
{
    "Version":"2012-10-17",
    "Statement":[{
      "Action":["sts:AssumeRole"],
      "Effect":"Allow",
      "Principal":{
        "Service":["ecs-tasks.amazonaws.com"]
      }}]
}
```

We run the files from the CLI to create the role and trust relationship in IAM.

```
aws iam create-role \
--role-name CruddurServiceExecutionRole \
--assume-role-policy-document file://aws/policies/service-assume-role-execution-policy.json
```

![Screenshot 2024-01-29 203747](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/091e84c6-3019-4636-93f7-e48d5e48dbe3)

![Screenshot 2024-01-30 031056](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/0d91b7f4-f728-463e-ab2f-6fd8af7a360b)



We then grant the CruddurTaskRole full access to Cloudwatch and write access to the AWS XRay Daemon:

```
aws iam attach-role-policy --policy-arn arn:aws:iam::aws:policy/CloudWatchFullAccess --role-name CruddurTaskRole
aws iam attach-role-policy --policy-arn arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess --role-name CruddurTaskRole

```

We can now begin working on our task definitions. From our workspace, we create a new folder from the aws directory named ‘task-definitions’ and then create a backend-flask.json file and a frontend-react-js.json file, filling in our own information.

```
{
  "family": "backend-flask",
  "executionRoleArn": "arn:aws:iam::AWS_ACCOUNT_ID:role/CruddurServiceExecutionRole",
  "taskRoleArn": "arn:aws:iam::AWS_ACCOUNT_ID:role/CruddurTaskRole",
  "networkMode": "awsvpc",
  "containerDefinitions": [
    {
      "name": "backend-flask",
      "image": "BACKEND_FLASK_IMAGE_URL",
      "cpu": 256,
      "memory": 512,
      "essential": true,
      "portMappings": [
        {
          "name": "backend-flask",
          "containerPort": 4567,
          "protocol": "tcp", 
          "appProtocol": "http"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
            "awslogs-group": "cruddur",
            "awslogs-region": "us-east-1",
            "awslogs-stream-prefix": "backend-flask"
        }
      },
      "environment": [
        {"name": "OTEL_SERVICE_NAME", "value": "backend-flask"},
        {"name": "OTEL_EXPORTER_OTLP_ENDPOINT", "value": "https://api.honeycomb.io"},
        {"name": "AWS_COGNITO_USER_POOL_ID", "value": ""},
        {"name": "AWS_COGNITO_USER_POOL_CLIENT_ID", "value": ""},
        {"name": "FRONTEND_URL", "value": "*"},
        {"name": "BACKEND_URL", "value": "*"},
        {"name": "AWS_DEFAULT_REGION", "value": "us-east-1"}
      ],
      "secrets": [
        {"name": "AWS_ACCESS_KEY_ID"    , "valueFrom": "arn:aws:ssm:AWS_REGION:AWS_ACCOUNT_ID:parameter/cruddur/backend-flask/AWS_ACCESS_KEY_ID"},
        {"name": "AWS_SECRET_ACCESS_KEY", "valueFrom": "arn:aws:ssm:AWS_REGION:AWS_ACCOUNT_ID:parameter/cruddur/backend-flask/AWS_SECRET_ACCESS_KEY"},
        {"name": "CONNECTION_URL"       , "valueFrom": "arn:aws:ssm:AWS_REGION:AWS_ACCOUNT_ID:parameter/cruddur/backend-flask/CONNECTION_URL" },
        {"name": "ROLLBAR_ACCESS_TOKEN" , "valueFrom": "arn:aws:ssm:AWS_REGION:AWS_ACCOUNT_ID:parameter/cruddur/backend-flask/ROLLBAR_ACCESS_TOKEN" },
        {"name": "OTEL_EXPORTER_OTLP_HEADERS" , "valueFrom": "arn:aws:ssm:AWS_REGION:AWS_ACCOUNT_ID:parameter/cruddur/backend-flask/OTEL_EXPORTER_OTLP_HEADERS" }
        
      ]
    }
  ]
}

```

```
{
  "family": "frontend-react-js",
  "executionRoleArn": "arn:aws:iam::AWS_ACCOUNT_ID:role/CruddurServiceExecutionRole",
  "taskRoleArn": "arn:aws:iam::AWS_ACCOUNT_ID:role/CruddurTaskRole",
  "networkMode": "awsvpc",
  "containerDefinitions": [
    {
      "name": "frontend-react-js",
      "image": "BACKEND_FLASK_IMAGE_URL",
      "cpu": 256,
      "memory": 256,
      "essential": true,
      "portMappings": [
        {
          "name": "frontend-react-js",
          "containerPort": 3000,
          "protocol": "tcp", 
          "appProtocol": "http"
        }
      ],

      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
            "awslogs-group": "cruddur",
            "awslogs-region": "us-east-1",
            "awslogs-stream-prefix": "frontend-react"
        }
      }
    }
  ]
}
```

After this is completed, we register our task definitions from the CLI.

```
aws ecs register-task-definition --cli-input-json file://aws/task-definitions/backend-flask.json
aws ecs register-task-definition --cli-input-json file://aws/task-definitions/frontend-react-js.json
```


We next set a variable for after finding the default VPC in AWS by running this:


```
export DEFAULT_VPC_ID=$(aws ec2 describe-vpcs \
--filters "Name=isDefault, Values=true" \
--query "Vpcs[0].VpcId" \
--output text)
echo $DEFAULT_VPC_ID
```

We then use it to setup our security group:

```
export CRUD_SERVICE_SG=$(aws ec2 create-security-group \
  --group-name "crud-srv-sg" \
  --description "Security group for Cruddur services on ECS" \
  --vpc-id $DEFAULT_VPC_ID \
  --query "GroupId" --output text)
echo $CRUD_SERVICE_SG
```

Then authorize port 80 for the security group:

```
aws ec2 authorize-security-group-ingress \
  --group-id $CRUD_SERVICE_SG \
  --protocol tcp \
  --port 80 \
  --cidr 0.0.0.0/0
```

Next, we create our backend-flask service through ECS in the AWS console manually. From ECS it looks like there’s an issue with our backend-flask cluster service. It’s giving an error regarding the permissions to ECR and the logs:CreateLogStream action. So to fix this, we go back to IAM and edit the policy for our CruddurServiceExecutionPolicy.

```
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": [
                "ecr:GetAuthorizationToken",
                "ecr:BatchCheckLayerAvailability",
                "ecr:GetDownloadUrlForLayer",
                "ecr:BatchGetImage",
                "logs:CreateLogStream",
                "logs:PutLogEvents"
            ],
            "Resource": "*"
        },
        {
            "Sid": "VisualEditor1",
            "Effect": "Allow",
            "Action": [
                "ssm:GetParameters",
                "ssm:GetParameter"
            ],
            "Resource": "arn:aws:ssm:us-east-1:554621479919:parameter/cruddur/backend-flask/*"
        }
    ]
}
```

![Screenshot 2024-01-30 140051](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/acd473ae-f12c-4a22-aca0-120a3894ade2)
![Screenshot 2024-01-30 183005](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/423e4681-8eea-4983-83a2-8b6878f6ef11)
![Screenshot 2024-01-30 180938](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/0f77a884-e900-4378-b3c5-407be3ec61f3)

We go back to ECS and force a new deployment of our service. When we check the task itself, it’s health status check came back as unknown.
![Screenshot 2024-01-30 183033](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/df2e15e8-6285-4cab-b97f-7cf6aa9adf76)

To troubleshoot the issue, we shelled into the task itself by running the following from CLI:

```
aws ecs execute-command \
--region $AWS_DEFAULT_REGION \
--cluster cruddur \
--task 99999999999999999999 \
--container backend-flask \
--command "/bin/bash" \
--interactive
```

Prior to this, we needed to install the Session Manager plugin for our CLI:

```
curl "https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb" -o "session-manager-plugin.deb"

sudo dpkg -i session-manager-plugin.deb
```

We’re still unable to shell into the task. As it turns out, we need to enable an option for the service. This can only be done through the CLI, so we create a new file in our ‘aws/json’ directory named ‘service-backend-flask.json’ to create the service, with our own information:


```
{
    "cluster": "cruddur",
    "launchType": "FARGATE",
    "desiredCount": 1,
    "enableECSManagedTags": true,
    "enableExecuteCommand": true,
    "loadBalancers": [
      {
          "targetGroupArn": "",
          "containerName": "backend-flask",
          "containerPort": 4567
      }
  ],
    "networkConfiguration": {
      "awsvpcConfiguration": {
        "assignPublicIp": "ENABLED",
        "securityGroups": [
          "sg-99999999999"
        ],
        "subnets": [
          "subnet-",
          "subnet-",
          "subnet-"
        ]
      }
    }
    "propagateTags": "SERVICE",
    "serviceName": "backend-flask",
    "taskDefinition": "backend-flask"
}
```


The ‘“enableExecuteCommand”: true’ option above is what we were needing to set. We relaunch the service, this time from the CLI:

```
aws ecs create-service --cli-input-json file://aws/json/service-backend-flask.json
```

![Screenshot 2024-01-30 230939](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/5e04df73-1c3f-4b38-8950-7cc82b7addfd)

![Screenshot 2024-01-31 031628](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/67dc39f1-ce12-41d1-b86f-d6a5cc05485a)
![Screenshot 2024-01-31 031617](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/b97838e4-3f22-47cf-a629-3ef7a2d50b7c)
![Screenshot 2024-01-31 023945](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/b49a0f51-acc8-4ef3-b09d-dc4cefcab53f)
![Screenshot 2024-01-31 031657](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/04c77be8-9bab-4ae7-af26-35be8df2e9b1)


We go back to ECS, grab the number from the recently started task, then again try to shell into the service task:

![image](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/ae704c9a-8975-4daa-9430-9e764e615738)

This time it works. We’re able to perform a health check on the task:
```
./bin/flask/health-check
```
The health check returns saying the Flask server is running. When we go back to ECS, the task is showing healthy there as well.


We create a new script for this process by creating a new folder in our ‘backend-flask/bin’ directory, named ‘ecs’, then a file inside named ‘connect-to-service’ where we copied the shell execute-command above into it. Then in our gitpod.yml file, to make sure Session Manager is installed in our environment at all times, we add a section for Fargate:

```
  - name: fargate 
    before: |
      cd /workspace
      curl "https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb" -o "session-manager-plugin.deb"
      sudo dpkg -i session-manager-plugin.deb 
      cd $THEIA_WORKSPACE_ROOT
      cd backend-flask
```

```
#! /usr/bin/bash
if [ -z "$1" ]; then
    echo "no TASK_ID argument supplied eg ./bin/ecs/connect-to-service 89a18169c70f41bd873e0395255291fa backend-flask"
    exit 1
fi
TASK_ID=$1

if [ -z "$2" ]; then
    echo "no CONTAINER_NAME argument supplied eg ./bin/ecs/connect-to-service 89a18169c70f41bd873e0395255291fa backend-flask"
    exit 1
fi
CONTAINER_NAME=$2

aws ecs execute-command \
--region $AWS_DEFAULT_REGION \
--cluster cruddur \
--task $TASK_ID \
--container $CONTAINER_NAME \
--command "/bin/bash" \
--interactive
```
![Screenshot 2024-01-31 031841](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/84263017-0fc6-4f5f-9cc7-a30c413e27ce)

From here, we go back to the AWS console, access EC2, then go to security groups. We must edit the inbound rules of our earlier created security group to open port 4567 for our backend-flask service to run. We also edit the default security group’s inbound rules, this way our service can interact with our backend.

![Screenshot 2024-01-31 032047](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/75cf2d35-82f6-44fb-9c34-023ab21ec274)


Earlier when creating our service-backend-flask.json file, we had removed code that we reinsert now:
```
    "serviceConnectConfiguration": {
      "enabled": true,
      "namespace": "cruddur",
      "services": [
        {
          "portName": "backend-flask",
          "discoveryName": "backend-flask",
          "clientAliases": [{"port": 4567}]
        }
      ]
    },
```

We again relaunch the service:
```
aws ecs create-service --cli-input-json file://aws/json/service-backend-flask.json
```
![Screenshot 2024-01-31 130647](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/b3d99d53-defd-4b24-9d60-2f7e45416a86)
![Screenshot 2024-01-31 130633](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/79cc2e27-0fd1-4df6-8473-6f6aa880abba)
![Screenshot 2024-01-31 124116](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/f80fd010-beb0-40a3-af3c-5c92fc606ae7)
![Screenshot 2024-01-31 124023](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/535d494c-682e-4170-a18b-6651416a23ec)



We now needed an application load balancer in place. We started by creating a new security group named cruddur-alb-sg.

![Screenshot 2024-01-31 153824](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/da4d8523-b9df-4227-97c3-7497d77c0a9f)


From there, edited the inbound rules of the crud-srv-sg security group to allow access for the ALB’s security group as well. 

![Screenshot 2024-01-31 153728](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/b987fbf0-0748-4dcf-a8ca-00e2320f061a)


Then we created a new target group with a target of IP addresses named cruddur-backend-flask-tg and another for the frontend named frontend-react-js. Created application load balancer named cruddur-alb using the cruddur-alb-sg security group and the cruddur-backend-flask-tg and frontend-react-js target groups.
![Screenshot 2024-01-31 154128](https://github.com/bhanumalhotra123/aws-bootcamp-cruddur-2023/assets/144083659/526bd9d7-ac5d-4002-8f84-c8fe9b35fd4f)

